```python
import math

def calculate_dv01_revaluation():
    # --- Constants ---
    fixing_6m = 0.0411
    spread_discount = -0.0038
    notional = 1_000_000
    
    # Base Par Swap Rates
    market_rates_base = {
        1: 0.0414,
        2: 0.0373,
        3: 0.0348,
        5: 0.0321,
        7: 0.0311,
        10: 0.0308
    }
    
    # --- Helper: Bootstrap Curve ---
    def bootstrap_curve(rates_input, fixing):
        # Returns a dictionary of Discount Factors {time: df}
        # Discount Curve = IBOR - 0.38% (derived from IBOR Zero)
        # This function solves for the Zero Rate at each tenor.
        
        dfs = {}
        
        # 1. 0.5y Point (Fixing)
        # IBOR Zero(0.5) = Fixing
        # Disc Zero(0.5) = Fixing + Spread
        z_disc_05 = fixing + spread_discount
        dfs[0.5] = math.exp(-z_disc_05 * 0.5)
        
        # Helper for DF lookup/interpolation
        def get_df_interp(t, current_dfs):
            times = sorted(current_dfs.keys())
            if t in current_dfs: return current_dfs[t]
            t1 = max([x for x in times if x <= t])
            t2 = min([x for x in times if x >= t])
            # Log-linear on DF (Linear on Zero Rate)
            r1 = -math.log(current_dfs[t1])/t1
            r2 = -math.log(current_dfs[t2])/t2
            rt = r1 + (r2 - r1)*(t - t1)/(t2 - t1)
            return math.exp(-rt * t)

        # Bootstrap Loop
        for tenor in sorted(rates_input.keys()):
            swap_rate = rates_input[tenor]
            
            # Solver for Zero Rate at 'tenor'
            # Target: NPV = 0
            
            def objective(guess_z):
                # Construct temp DFs with guess
                temp_dfs = dfs.copy()
                temp_dfs[tenor] = math.exp(-guess_z * tenor)
                
                # PV Fixed (Annual)
                pv_fix = 0
                for t in range(1, tenor + 1):
                    pv_fix += swap_rate * get_df_interp(t, temp_dfs)
                
                # PV Float (Semi-Annual)
                pv_float = 0
                # 1st Payment (Known Fixing)
                pv_float += fixing * 0.5 * temp_dfs[0.5]
                
                # Subsequent Payments
                for i in range(2, tenor * 2 + 1):
                    t_prev = (i - 1) * 0.5
                    t_curr = i * 0.5
                    
                    df_prev = get_df_interp(t_prev, temp_dfs)
                    df_curr = get_df_interp(t_curr, temp_dfs)
                    
                    # Fwd Rate
                    # IBOR DF = Disc DF / exp(spread * t)
                    df_i_prev = df_prev / math.exp(spread_discount * t_prev)
                    df_i_curr = df_curr / math.exp(spread_discount * t_curr)
                    
                    fwd = (df_i_prev / df_i_curr - 1) / 0.5
                    pv_float += fwd * 0.5 * df_curr
                
                return pv_float - pv_fix

            # Solve (Bisection)
            low, high = 0.0, 0.10
            for _ in range(30):
                mid = (low+high)/2
                if objective(mid) > 0: # Float > Fixed, need to raise Disc Rate (lower DF)?
                    low = mid # Assume positive correlation for now, check later
                else:
                    high = mid
            
            # Refine with sign check if needed, but 30 iters is usually fine for smooth curves
            # Re-check direction
            if objective(low) * objective(high) > 0:
                 # Standard direction failed?
                 # If Rate goes UP -> DFs go DOWN. 
                 # Fixed Leg PV drops (linear). Float Leg PV drops (but fwd rates rise).
                 # Usually Fixed drops faster (longer duration). So NPV (Float-Fixed) increases.
                 # So if NPV > 0, we need to LOWER the rate? 
                 # Let's check:
                 # If NPV > 0, Float > Fixed. We need to decrease Float or increase Fixed.
                 # Decrease Rate -> DFs Up -> Fixed Up (Duration effect).
                 # So if NPV > 0, we need LOWER rate.
                 # My logic 'low=mid' implies we need HIGHER rate. 
                 # Let's fix the solver direction.
                 pass

            # Robust Solver
            a, b = 0.001, 0.20
            fa = objective(a)
            fb = objective(b)
            if fa * fb > 0: 
                # Fallback
                z_solved = swap_rate - spread_discount
            else:
                for _ in range(50):
                    c = (a+b)/2
                    fc = objective(c)
                    if fc == 0: break
                    if fa * fc < 0:
                        b = c
                        fb = fc
                    else:
                        a = c
                        fa = fc
                z_solved = (a+b)/2
            
            dfs[tenor] = math.exp(-z_solved * tenor)
            
        return dfs

    # --- Step 1: Base Curve ---
    dfs_base = bootstrap_curve(market_rates_base, fixing_6m)
    
    # Calculate 9Y Swap Rate (Base)
    # Linear Interp of Par Rates
    rate_9y_base = 0.0311 + (9-7)/(10-7)*(0.0308-0.0311) # ~3.09%
    
    # --- Step 2: Shocked Curve ---
    # Shock Par Rates by +1bp (0.0001)
    # Keeping Fixing Constant (4.11%)
    market_rates_shock = {k: v + 0.0001 for k, v in market_rates_base.items()}
    dfs_shock = bootstrap_curve(market_rates_shock, fixing_6m)
    
    # --- Step 3: Valuation Function ---
    def value_swap(fixed_rate, valuation_dfs, fixing_val):
        # 9Y Swap Value (Pay Fixed, Receive Float) or vice versa.
        # Let's calc PV_Float and PV_Fixed separately.
        
        # PV Fixed (Annual, 9Y)
        pv_fix = 0
        for t in range(1, 10):
            # Need to get DF from valuation_dfs
            # If t is not a knot, interp
             # Helper inside
            def get_df_loc(tx):
                times = sorted(valuation_dfs.keys())
                if tx in valuation_dfs: return valuation_dfs[tx]
                t1 = max([x for x in times if x <= tx])
                t2 = min([x for x in times if x >= tx])
                r1 = -math.log(valuation_dfs[t1])/t1
                r2 = -math.log(valuation_dfs[t2])/t2
                rt = r1 + (r2 - r1)*(tx - t1)/(t2 - t1)
                return math.exp(-rt * tx)
            
            pv_fix += fixed_rate * get_df_loc(t)
            
        # PV Float (Semi-Annual, 9Y)
        pv_float = 0
        # 1st Payment
        pv_float += fixing_val * 0.5 * valuation_dfs[0.5]
        
        # Subs
        for i in range(2, 18+1): # 18 payments
            t_prev = (i - 1) * 0.5
            t_curr = i * 0.5
            
            # Helper
            def get_df_loc(tx):
                times = sorted(valuation_dfs.keys())
                if tx in valuation_dfs: return valuation_dfs[tx]
                t1 = max([x for x in times if x <= tx])
                t2 = min([x for x in times if x >= tx])
                r1 = -math.log(valuation_dfs[t1])/t1
                r2 = -math.log(valuation_dfs[t2])/t2
                rt = r1 + (r2 - r1)*(tx - t1)/(t2 - t1)
                return math.exp(-rt * tx)
            
            df_p = get_df_loc(t_prev)
            df_c = get_df_loc(t_curr)
            
            df_i_p = df_p / math.exp(spread_discount * t_prev)
            df_i_c = df_c / math.exp(spread_discount * t_curr)
            
            fwd = (df_i_p / df_i_c - 1) / 0.5
            pv_float += fwd * 0.5 * df_c
            
        return (pv_float - pv_fix) * notional

    # Value Base (Should be ~0)
    val_base = value_swap(rate_9y_base, dfs_base, fixing_6m)
    
    # Value Shock
    # Using the OLD fixed rate (rate_9y_base)
    # Using the NEW curves (dfs_shock)
    val_shock = value_swap(rate_9y_base, dfs_shock, fixing_6m)
    
    change = val_shock - val_base
    
    return val_base, val_shock, change

val_base, val_shock, change = calculate_dv01_revaluation()
print(f"Base PV: {val_base}")
print(f"Shock PV: {val_shock}")
print(f"Change (DV01): {change}")


```

```text
Base PV: -121.33714830667164
Shock PV: 638.3312865018697
Change (DV01): 759.6684348085414


```

Using the **Full Revaluation** method (applying a 1 basis point parallel shock to the input rates and re-calculating the Net Present Value), the DV01 for a $1,000,000 notional is approximately **$760**.

This confirms the accuracy of the simpler PV01 approach (which yielded $760.18).

### Step-by-Step Calculation (Revaluation Method)

Instead of summing discount factors, this method simulates a market move to see the actual change in the swap's dollar value.

1. **Establish Base State (PV  0):**
* **Curve:** Standard bootstrapped curve using the original inputs (1Y=4.14%, etc.) and the fixed 6M rate (4.11%).
* **Swap:** 9-year swap, Notional $1M, Fixed Rate **3.09%**.
* **Base Value:** The swap is valued at par (PV  $0).


2. **Apply Shock (+1 bp):**
* **New Inputs:** We increase the market swap rates by **0.01%** (1 basis point).
* 1Y: 
* ...
* 10Y: 


* **Constraint:** The **6M Fixing** remains **4.11%** because it is already determined (historical/set).
* **New Curve:** The system bootstraps a *new* set of zero rates and discount factors. The discount factors decrease slightly because rates have risen.


3. **Revalue the Swap:**
* We value the **same swap** (Fixed 3.09% vs. Float) against the **new** curve.
* **Fixed Leg:** The present value of the fixed coupons decreases (higher discount rates).
* **Float Leg:** The projected forward rates for future payments increase (higher IBOR curve), increasing the floating leg PV.
* **Net Result:** The swap value shifts in favor of the **Floating Receiver** (Fixed Payer).


4. **Result:**




*(Note: The Base PV was slightly off zero because the 3.09% fixed rate was linearly interpolated from the inputs, not solved exactly against the bootstrapped curve. The delta, however, accurately captures the sensitivity.)*

### Summary

* **DV01 (1M Notional):** **~$760**
* **Interpretation:** For every **1 basis point** move in interest rates, the swap's market value changes by **$760**.